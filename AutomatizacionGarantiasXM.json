{
  "files": [
    {
      "id": "4f07958d-3a9e-4d03-8ec7-fde406501fd3",
      "name": "appsscript",
      "type": "json",
      "source": "{\n  \"timeZone\": \"America/Bogota\",\n  \"dependencies\": {\n    \"enabledAdvancedServices\": [\n      {\n        \"userSymbol\": \"Drive\",\n        \"version\": \"v2\",\n        \"serviceId\": \"drive\"\n      }\n    ]\n  },\n  \"exceptionLogging\": \"STACKDRIVER\",\n  \"runtimeVersion\": \"V8\"\n}"
    },
    {
      "id": "50971e05-8252-49ea-9f44-52afdeb8ee2d",
      "name": "C√≥digo",
      "type": "server_js",
      "source": "function automatizacionGarantiasXM() {\n  const nombreCarpetaPrincipal = \"Garant√≠as\";\n  const nombreArchivoMaestro = \"AutomatizacionGarantias\";\n  const fechaHoy = new Date();\n  fechaHoy.setHours(0,0,0,0);\n  \n  try {\n    // --- PREPARACI√ìN INICIAL ---\n    const iterCarpetas = DriveApp.getFoldersByName(nombreCarpetaPrincipal);\n    if (!iterCarpetas.hasNext()) throw \"No se encontr√≥ la carpeta 'Garant√≠as'.\";\n    const carpetaRaiz = iterCarpetas.next();\n    \n    const iterMaestros = DriveApp.getFilesByName(nombreArchivoMaestro);\n    if (!iterMaestros.hasNext()) throw \"No se encontr√≥ el archivo maestro.\";\n    const hojaMaestra = SpreadsheetApp.open(iterMaestros.next()).getSheets()[0];\n    const datosMaestros = hojaMaestra.getDataRange().getValues();\n\n    // Mapear subcarpetas disponibles\n    const carpetas = {};\n    const subcarpetas = carpetaRaiz.getFolders();\n    while (subcarpetas.hasNext()) {\n      let sub = subcarpetas.next();\n      carpetas[sub.getName().toUpperCase()] = sub;\n    }\n\n    // --- FASE 1: LECTURA Y PROCESAMIENTO DE ARCHIVOS (UNA SOLA VEZ) ---\n    // Estructura: mapaDeudas[CODIGO_AGENTE] = [ {archivo, valor, vencimiento}, ... ]\n    const mapaDeudas = {}; \n\n    // Identificar carpetas relevantes para escanear (excluyendo CUENTAS)\n    // Asumimos que cualquier carpeta que no sea CUENTAS puede contener garant√≠as\n    for (let nombreCarpeta in carpetas) {\n      if (nombreCarpeta === \"CUENTAS\") continue;\n      \n      let esTIE = (nombreCarpeta === \"TIE\");\n      let carpeta = carpetas[nombreCarpeta];\n      let archivos = carpeta.getFiles();\n      \n      while (archivos.hasNext()) {\n        let archivo = archivos.next();\n        let fechaDoc = extraerFechaDelNombre(archivo.getName());\n        \n        // Solo procesar archivos con fecha >= hoy\n        if (fechaDoc && fechaDoc >= fechaHoy) {\n          Logger.log(`Procesando archivo: ${archivo.getName()} (${nombreCarpeta})`);\n          \n          // Convertir y leer archivo UNA SOLA VEZ\n          let matriz = obtenerMatrizConvertida(archivo);\n          if (!matriz) continue;\n          \n          // Iterar filas del archivo para extraer deudas de TODOS los agentes presentes\n          for (let f = 0; f < matriz.length; f++) {\n            let codigoFila = matriz[f][0] ? matriz[f][0].toString().trim().toUpperCase() : \"\";\n            if (!codigoFila || codigoFila === \"CODIGO\" || codigoFila === \"AGENTE\") continue;\n            \n            let valor = 0;\n            if (esTIE) {\n              // TIE: Valor en columna D (√≠ndice 3)\n              valor = parseFloat(matriz[f][3]) || 0;\n            } else {\n              // Esquema normal: Sumar columnas desde la D (√≠ndice 3) en adelante\n              for (let c = 3; c < matriz[f].length; c++) {\n                let celda = matriz[f][c] ? matriz[f][c].toString() : \"0\";\n                let n = parseFloat(celda.replace(/[^\\d.-]/g, ''));\n                if (!isNaN(n)) valor += n;\n              }\n            }\n            \n            // Si hay deuda relevante, agregar al mapa global del agente\n            if (Math.abs(valor) > 0.01) {\n              if (!mapaDeudas[codigoFila]) mapaDeudas[codigoFila] = [];\n              mapaDeudas[codigoFila].push({\n                archivo: archivo.getName(),\n                valor: valor,\n                vencimiento: fechaDoc.toLocaleDateString('es-CO')\n              });\n            }\n          }\n        }\n      }\n    }\n\n    // --- FASE 2: OBTENER SALDOS (UNA SOLA VEZ) ---\n    const saldosCuentas = obtenerSaldosMasRecientes(carpetas[\"CUENTAS\"]);\n\n    // --- FASE 3: ENV√çO DE CORREOS (Iterando Lista Maestra) ---\n    let correosEnviados = 0;\n    for (let i = 1; i < datosMaestros.length; i++) {\n      let codBuscado = datosMaestros[i][0] ? datosMaestros[i][0].toString().trim().toUpperCase() : \"\";\n      let correo = datosMaestros[i][1];\n      let nombreAgente = datosMaestros[i][2];\n      let esquemaAgente = datosMaestros[i][3] ? datosMaestros[i][3].toString().trim().toUpperCase() : \"\";\n      let cuentaAgente = datosMaestros[i][4] ? datosMaestros[i][4].toString().trim() : \"\"; \n\n      if (!codBuscado || !correo) continue;\n\n      // Recuperar deudas pre-calculadas del mapa\n      let resumenDeudas = mapaDeudas[codBuscado] || [];\n      \n      // Recuperar info de saldo\n      let infoSaldo = saldosCuentas[cuentaAgente] || { saldo: 0, fecha: \"No encontrada\" };\n      \n      // Enviar correo si hay algo que reportar (deuda o saldo)\n      // Opcional: ¬øEnviar siempre? El script original enviaba siempre.\n      enviarNotificacionCompleta(nombreAgente, codBuscado, correo, esquemaAgente, resumenDeudas, infoSaldo, cuentaAgente);\n      correosEnviados++;\n    }\n    \n    Logger.log(`‚úÖ Proceso finalizado. Correos enviados: ${correosEnviados}`);\n    \n  } catch (e) {\n    Logger.log(\"‚ùå Error General: \" + e.toString());\n    if (e.stack) Logger.log(e.stack);\n  }\n}\n\n// --- FUNCIONES AUXILIARES ---\n\nfunction obtenerSaldosMasRecientes(carpetaCuentas) {\n  if (!carpetaCuentas) return {};\n  let archivos = carpetaCuentas.getFiles();\n  let archivoMasReciente = null;\n  let ultimaFecha = new Date(0);\n\n  while (archivos.hasNext()) {\n    let arc = archivos.next();\n    let f = extraerFechaDelNombre(arc.getName());\n    if (f && f > ultimaFecha) {\n      ultimaFecha = f;\n      archivoMasReciente = arc;\n    }\n  }\n\n  if (!archivoMasReciente) return {};\n\n  let matriz = obtenerMatrizConvertida(archivoMasReciente);\n  if (!matriz) return {};\n  \n  let mapaSaldos = {};\n  for (let f = 0; f < matriz.length; f++) {\n    let cuenta = matriz[f][1] ? matriz[f][1].toString().trim() : \"\"; // Columna B\n    let saldo = parseFloat(matriz[f][9]) || 0; // Columna J\n    if (cuenta) {\n      mapaSaldos[cuenta] = { saldo: saldo, fecha: ultimaFecha.toLocaleDateString() };\n    }\n  }\n  return mapaSaldos;\n}\n\nfunction enviarNotificacionCompleta(nombre, cod, correo, esquema, deudas, infoSaldo, cuenta) {\n  let totalDeuda = deudas.reduce((acc, d) => acc + d.valor, 0);\n  let diferencia = infoSaldo.saldo - totalDeuda;\n  let asunto = `Resumen de Garant√≠as y Cuenta Custodia - ${cod}`;\n  \n  let cuerpo = `Estimado ${nombre},\\n\\n`;\n  cuerpo += `Se han procesado los reportes de garant√≠as vigentes para el esquema ${esquema} e Internacionales (TIE). Detalle:\\n\\n`;\n\n  if (deudas.length > 0) {\n    deudas.forEach(d => {\n      let etiqueta = d.valor < 0 ? \"SALDO A FAVOR\" : \"VALOR A PAGAR\";\n      let signo = d.valor < 0 ? \" (-)\" : \"\";\n      cuerpo += `‚Ä¢ ARCHIVO: ${d.archivo}\\n`;\n      cuerpo += `  ${etiqueta}: $${Math.abs(d.valor).toLocaleString('es-CO', { minimumFractionDigits: 2 })}${signo}\\n`;\n      cuerpo += `  VENCE: ${d.vencimiento}\\n\\n`;\n    });\n    cuerpo += `-------------------------------------------\\n`;\n    cuerpo += `TOTAL NETO CONSOLIDADO: $${totalDeuda.toLocaleString('es-CO', { minimumFractionDigits: 2 })}\\n`;\n    cuerpo += `-------------------------------------------\\n\\n`;\n  } else {\n    cuerpo += `‚Ä¢ No se identificaron garant√≠as pendientes por cubrir.\\n\\n`;\n  }\n\n  cuerpo += `ESTADO DE CUENTA CUSTODIA\\n`;\n  cuerpo += `Cuenta No: ${cuenta}\\n`;\n  cuerpo += `Saldo Disponible: $${infoSaldo.saldo.toLocaleString('es-CO', { minimumFractionDigits: 2 })}\\n`;\n  cuerpo += `Fecha de Corte: ${infoSaldo.fecha}\\n\\n`;\n\n  cuerpo += `AN√ÅLISIS DE COBERTURA:\\n`;\n  if (diferencia >= 0) {\n    cuerpo += `‚úÖ SALDO SUFICIENTE: El saldo disponible cubre las obligaciones actuales. \\n`;\n    cuerpo += `   Sobrante estimado: $${diferencia.toLocaleString('es-CO', { minimumFractionDigits: 2 })}\\n\\n`;\n  } else {\n    cuerpo += `‚ö†Ô∏è SALDO INSUFICIENTE: Se requiere un fondeo adicional en la cuenta.\\n`;\n    cuerpo += `   Monto m√≠nimo a transferir: $${Math.abs(diferencia).toLocaleString('es-CO', { minimumFractionDigits: 2 })}\\n\\n`;\n  }\n\n  if (totalDeuda < 0) {\n    cuerpo += `Nota: El saldo total neto de garant√≠as es a su favor.\\n\\n`;\n  }\n\n  cuerpo += `Cordialmente,\\n\\nENERCONSULT`;\n\n  try {\n    GmailApp.sendEmail(correo, asunto, cuerpo);\n    Logger.log(`üì§ Notificaci√≥n enviada a ${cod}`);\n  } catch (e) {\n    Logger.log(`‚ö†Ô∏è Error enviando correo a ${cod}: ${e.toString()}`);\n  }\n}\n\nfunction extraerFechaDelNombre(nombre) {\n  const meses = {\"JAN\":0,\"FEB\":1,\"MAR\":2,\"APR\":3,\"MAY\":4,\"JUN\":5,\"JUL\":6,\"AUG\":7,\"SEP\":8,\"OCT\":9,\"NOV\":10,\"DEC\":11,\"ENE\":0,\"ABR\":3,\"AGO\":7,\"DIC\":11};\n  let m1 = nombre.match(/(\\d{1,2})(JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC|ENE|ABR|AGO|DIC)[- ]?(\\d{4})/i);\n  if (m1) return new Date(m1[3], meses[m1[2].toUpperCase()], m1[1]);\n  let m2 = nombre.match(/(\\d{4})[-/](\\d{1,2})[-/](\\d{1,2})/) || nombre.match(/(\\d{1,2})[-/](\\d{1,2})[-/](\\d{4})/);\n  if (m2) {\n    if (m2[1].length === 4) return new Date(m2[1], parseInt(m2[2])-1, m2[3]);\n    return new Date(m2[3], parseInt(m2[2])-1, m2[1]);\n  }\n  return null;\n}\n\nfunction obtenerMatrizConvertida(archivo) {\n  let tempFileId = null;\n  try {\n    // Conversi√≥n de Excel a Google Sheets\n    const resource = {\n      title: \"TEMP_\" + new Date().getTime(),\n      mimeType: MimeType.GOOGLE_SHEETS\n    };\n    const tempFile = Drive.Files.insert(resource, archivo.getBlob(), {convert: true});\n    tempFileId = tempFile.id;\n    \n    const sheet = SpreadsheetApp.openById(tempFileId).getSheets()[0];\n    const data = sheet.getDataRange().getValues();\n    return data;\n  } catch(e) {\n    Logger.log(\"‚ö†Ô∏è Error convirtiendo archivo \" + archivo.getName() + \": \" + e.toString());\n    return null;\n  } finally {\n    // Limpieza inmediata\n    if (tempFileId) {\n      try {\n        Drive.Files.remove(tempFileId);\n      } catch (e2) {\n        Logger.log(\"‚ö†Ô∏è No se pudo borrar archivo temporal: \" + tempFileId);\n      }\n    }\n  }\n}"
    }
  ]
}